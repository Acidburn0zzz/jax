Jax.shaders['normal_map'] = new Jax.Shader({  common:"uniform sampler2D NormalMap;\n\nshared uniform mat4 mvMatrix, pMatrix;\nshared uniform mat3 nMatrix, vMatrix;\n\nshared uniform LightSource LIGHT;\n\nshared varying vec2 vTexCoords;\n\nvarying vec3 vEyeDir;\nvarying vec3 vLightDir;\nvarying float vAttenuation;\n\n",
  fragment:"void main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  // ambient was applied by the basic shader; applying it again will simply brighten some fragments\n  // beyond their proper ambient value. So, we really need to apply the bump shader ONLY to diffuse+specular.\n\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%>) return;\n  \n  vec3 nLightDir = normalize(vLightDir);\n  vec3 nEyeDir = normalize(vEyeDir);\n  vec4 color = texture2D(NormalMap, vTexCoords);\n  vec3 map = nMatrix * normalize(color.xyz * 2.0 - 1.0);\n\n  float litColor = max(dot(map, nLightDir), 0.0) * vAttenuation;\n\n  // specular\n  vec3 reflectDir = reflect(nLightDir, map);\n  float spec = max(dot(nEyeDir, reflectDir), 0.0);\n  spec = pow(spec, materialShininess);\n  // Treat alpha in the normal map as a specular map; if it's unused it will be 1 and this\n  // won't matter.\n  spec *= color.a;\n  litColor = min(litColor+spec, 1.0);\n  \n  diffuse *= litColor;\n  specular *= litColor;\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION;\nshared attribute vec2 VERTEX_TEXCOORDS;\nshared attribute vec4 VERTEX_TANGENT;\nshared attribute vec3 VERTEX_NORMAL;\n\nvoid main(void) {\n  // ambient was applied by the basic shader; applying it again will simply brighten some fragments\n  // beyond their proper ambient value. So, we really need to apply the bump shader ONLY to diffuse+specular.\n\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%>) return;\n\n  vec3 ecPosition = vec3(mvMatrix * VERTEX_POSITION);\n\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  vTexCoords = VERTEX_TEXCOORDS;\n\n  vEyeDir = vec3(mvMatrix * VERTEX_POSITION);\n  \n  vec3 n = normalize(nMatrix * VERTEX_NORMAL);\n  vec3 t = normalize(nMatrix * VERTEX_TANGENT.xyz);\n  vec3 b = cross(n, t) * VERTEX_TANGENT.w;\n  \n  vec3 v, p;\n  \n  vAttenuation = 1.0;\n  \n  if (LIGHT.type == <%=Jax.POINT_LIGHT%>)\n    if (LIGHT.constant_attenuation == 1.0 && LIGHT.linear_attenuation == 0.0 && LIGHT.quadratic_attenuation == 0.0) {\n      // no change to attenuation, but we still need P\n      p = vec3(ivMatrix * vec4(LIGHT.position, 1.0)) - ecPosition;\n    }\n    else {\n      // attenuation calculation figures out P for us, so we may as well use it\n      vAttenuation = calcAttenuation(LIGHT, ecPosition, p);\n    }\n  else\n    if (LIGHT.type == <%=Jax.SPOT_LIGHT%>) {\n      // attenuation calculation figures out P for us, so we may as well use it\n      vAttenuation = calcAttenuation(LIGHT, ecPosition, p);\n    }\n    else\n    { // directional light -- all we need is P\n      p = vec3(vnMatrix * -normalize(LIGHT.direction));\n    }\n    \n    \n    \n  v.x = dot(p, t);\n  v.y = dot(p, b);\n  v.z = dot(p, n);\n  vLightDir = normalize(p);\n  \n  v.x = dot(vEyeDir, t);\n  v.y = dot(vEyeDir, b);\n  v.z = dot(vEyeDir, n);\n  vEyeDir = normalize(v);\n}\n",
exports: {},
name: "normal_map"});
