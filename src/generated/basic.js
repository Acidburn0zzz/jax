Jax.shaders['basic'] = new Jax.Shader({  common:"<% for (var i = 0; i < textures.length; i++) { %>\n     uniform sampler2D TEXTURE<%=i%>;\n     uniform int TEXTURE<%=i%>_TYPE;\n     uniform vec2 TEXTURE<%=i%>_SCALE, TEXTURE<%=i%>_OFFSET;\n<% } %>\n\nuniform mat4 mMatrix, ivMatrix, mvMatrix, pMatrix, vMatrix;\nuniform mat3 vnMatrix, nMatrix;\n\nuniform vec4 materialDiffuse, materialAmbient, materialSpecular;\nuniform float materialShininess;\n\nuniform int PASS_TYPE;\n\nvarying vec2 vTexCoords;\nvarying vec3 vNormal, vLightDir, vTbnDirToLight;\nvarying vec4 vBaseColor;\n\n\nconst struct LightSource {\n  vec3 position; // in world space\n  vec3 direction; // in world space\n  vec4 ambient, diffuse, specular;\n  float constant_attenuation, linear_attenuation, quadratic_attenuation;\n  float spotExponent, spotCosCutoff;\n};\n\nvoid DirectionalLight(const in LightSource light,\n                      in vec3 normal,\n                      inout vec4 ambient,\n                      inout vec4 diffuse,\n                      inout vec4 specular)\n{\n  vec3 nLDir = normalize(vnMatrix * -normalize(light.direction));\n  vec3 halfVector = normalize(nLDir + vec3(0,0,1));\n  float pf;\n  \n  float NdotD  = max(0.0, dot(normal, nLDir));\n  float NdotHV = max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += light.ambient;\n  diffuse += light.diffuse * NdotD;\n  specular += light.specular * pf;\n}\n\n/* Use when attenuation != (1,0,0) */\nvoid PointLightWithAttenuation(const in LightSource light,\n                               in vec3 ecPosition3,\n                               in vec3 normal,\n                               inout vec4 ambient,\n                               inout vec4 diffuse,\n                               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  float d;     // distance from surface to light source\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  VP = light.position - ecPosition3;\n  d = length(VP);\n  VP = normalize(VP);\n  attenuation = 1.0 / (light.constant_attenuation + light.linear_attenuation * d + light.quadratic_attenuation * d * d);\n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += light.ambient * attenuation;\n  diffuse += light.diffuse * NdotD * attenuation;\n  specular += light.specular * pf * attenuation;\n}\n\n/* Use for better performance when attenuation == (1,0,0) */\nvoid PointLightWithoutAttenuation(const in LightSource light,\n                                  in vec3 ecPosition3,\n                                  in vec3 normal,\n                                  inout vec4 ambient,\n                                  inout vec4 diffuse,\n                                  inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float d;     // distance from surface to light source\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  VP = light.position - ecPosition3;\n  d = length(VP);\n  VP = normalize(VP);\n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += light.ambient;\n  diffuse += light.diffuse * NdotD;\n  specular += light.specular * pf;\n}\n\nvoid SpotLight(const in LightSource light,\n               in vec3 ecPosition3,\n               in vec3 normal,\n               inout vec4 ambient,\n               inout vec4 diffuse,\n               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  float d;     // distance from surface to light source\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  float spotDot; // cosine of angle between spotlight\n  float spotAttenuation; // spotlight attenuation factor\n  \n  VP = light.position - ecPosition3;\n  d = length(VP);\n  VP = normalize(VP);\n  attenuation = 1.0 / (light.constant_attenuation + light.linear_attenuation * d + light.quadratic_attenuation * d * d);\n  \n  // See if point on surface is inside cone of illumination\n  spotDot = dot(-VP, normalize(light.direction));\n  if (spotDot < light.spotCosCutoff)\n    spotAttenuation = 0.0;\n  else spotAttenuation = pow(spotDot, light.spotExponent);\n  \n  attenuation *= spotAttenuation;\n  \n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += light.ambient * attenuation;\n  diffuse += light.diffuse * NdotD * attenuation;\n  specular += light.specular * pf * attenuation;\n}\n\n\n\nLightSource LIGHT = LightSource(\n  vec3(0), // position\n  vec3(-1.0, -1.0, -1.0), // direction\n  vec4(0.4, 0.4, 0.4, 1.0), // ambient\n  vec4(0.6, 0.6, 0.6, 1.0), // diffuse\n  vec4(1.0, 1.0, 1.0, 1.0), // specular\n  1.0,     // constant atten\n  0.0,     // linear atten\n  0.0,     // quadratic atten\n  0.0,     // spotExponent\n  0.0      // spotCosCutoff\n);\n",
  fragment:"void main(void) {\n  vec4 ambient = vec4(0);\n  vec4 diffuse = vec4(0), specular = vec4(0);\n  \n  vec3 nTbnDirToLight = normalize(vTbnDirToLight);\n\n  vec3 nNormal = normalize(vNormal);\n\n  DirectionalLight(LIGHT, nNormal, ambient, diffuse, specular);\n  \n  vec3 tn;\n  vec2 tc;\n  <% for (var i = 0; i < textures.length; i++) { %>\n    tc = vTexCoords * TEXTURE<%=i%>_SCALE + TEXTURE<%=i%>_OFFSET;\n    if (TEXTURE<%=i%>_TYPE == <%=Jax.NORMAL_MAP%>) {\n      tn = normalize(texture2D(TEXTURE<%=i%>, tc).xyz * 2.0 - 1.0);\n      diffuse *= max(dot(nTbnDirToLight, tn), 0.0);\n    } else ambient *= texture2D(TEXTURE<%=i%>, tc);\n  <% } %>\n\n  gl_FragColor = ambient  * materialAmbient  * vBaseColor +\n                 diffuse  * materialDiffuse  * vBaseColor +\n                 specular * materialSpecular * vBaseColor;\n\n  /*\n    vec3 nLightDir = normalize(vLightDir), nNormal = normalize(vNormal);\n    vec3 halfVector = normalize(nLightDir + vec3(0,0,1));\n    float NdotL = max(dot(nNormal, nLightDir), 0.0);\n    vec4 diffuse = vec4(0,0,0,0);\n\n    if (NdotL > 0.0) {\n      float NdotHV = max(dot(nNormal, halfVector), 0.0);\n      diffuse += vBaseColor * NdotL * materialDiffuse * LIGHT.diffuse;\n      diffuse += vBaseColor * materialSpecular * LIGHT.specular * pow(NdotHV, materialShininess);\n    }\n\n    vec3 tn;\n    vec2 tc;\n    <% for (var i = 0; i < textures.length; i++) { %>\n      tc = vTexCoords * TEXTURE<%=i%>_SCALE + TEXTURE<%=i%>_OFFSET;\n      if (TEXTURE<%=i%>_TYPE == <%=Jax.NORMAL_MAP%>) {\n        tn = normalize(texture2D(TEXTURE<%=i%>, tc).xyz * 2.0 - 1.0);\n        diffuse *= max(dot(nTbnDirToLight, tn), 0.0);\n      } else ambient *= texture2D(TEXTURE<%=i%>, tc);\n    <% } %>\n\n    gl_FragColor = ambient + diffuse;\n    */\n//  } else discard;\n}\n",
  vertex:"attribute vec2 VERTEX_TEXCOORDS;\nattribute vec3 VERTEX_NORMAL;\nattribute vec4 VERTEX_POSITION, VERTEX_COLOR, VERTEX_TANGENT;\n\nvoid main(void) {\n  vBaseColor = VERTEX_COLOR;\n  vNormal = nMatrix * VERTEX_NORMAL;\n  vTexCoords = VERTEX_TEXCOORDS;\n\n  vec3 tangent = nMatrix * VERTEX_TANGENT.xyz;\n  vec3 bitangent = cross(vNormal, tangent) * VERTEX_TANGENT.w;\n  vec3 dirToEye = -(mvMatrix * VERTEX_POSITION).xyz;\n  vec3 tbnDirToEye = vec3(dot(dirToEye, tangent),\n                          dot(dirToEye, bitangent),\n                          dot(dirToEye, vNormal));\n                          \n  vLightDir = normalize(vnMatrix * -normalize(LIGHT.direction));\n  vTbnDirToLight.x = dot(vLightDir, tangent);\n  vTbnDirToLight.y = dot(vLightDir, bitangent);\n  vTbnDirToLight.z = dot(vLightDir, vNormal);\n\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n}\n",
name: "basic"});
