Jax.shaders['basic'] = new Jax.Shader({  common:"<% for (var i = 0; i < textures.length; i++) { %>\n     uniform sampler2D TEXTURE<%=i%>;\n     uniform int TEXTURE<%=i%>_TYPE;\n     uniform vec2 TEXTURE<%=i%>_SCALE, TEXTURE<%=i%>_OFFSET;\n<% } %>\n\nuniform mat4 mMatrix, ivMatrix, mvMatrix, pMatrix, vMatrix;\nuniform mat3 vnMatrix, nMatrix;\n\nuniform vec4 materialDiffuse, materialAmbient, materialSpecular;\nuniform float materialShininess;\n\nuniform int PASS_TYPE;\n\nvarying vec2 vTexCoords;\nvarying vec3 vNormal, vLightDir, vTbnDirToLight;\nvarying vec4 vBaseColor;\n\nconst vec4 LIGHT_AMBIENT = vec4(0.4,0.4,0.4,1.0);\nconst vec4 LIGHT_DIFFUSE = vec4(0.6,0.6,0.6,1.0);\nconst vec4 LIGHT_SPECULAR= vec4(1.0,1.0,1.0,1.0);\nconst vec3 LIGHT_DIRECTION=vec3(-1.0,-1.0,-1.0);\n",
  fragment:"void main(void) {\n  vec4 ambient = materialAmbient * vBaseColor + LIGHT_AMBIENT * vBaseColor;\n  vec3 nTbnDirToLight = normalize(vTbnDirToLight);\n\n  if (PASS_TYPE != <%=Jax.Scene.ILLUMINATION_PASS%>) {\n    vec3 nLightDir = normalize(vLightDir), nNormal = normalize(vNormal);\n    vec3 halfVector = normalize(nLightDir + vec3(0,0,1));\n    float NdotL = max(dot(nNormal, nLightDir), 0.0);\n    vec4 diffuse = vec4(0,0,0,0);\n\n    if (NdotL > 0.0) {\n      float NdotHV = max(dot(nNormal, halfVector), 0.0);\n      diffuse += vBaseColor * NdotL * materialDiffuse * LIGHT_DIFFUSE;\n      diffuse += vBaseColor * materialSpecular * LIGHT_SPECULAR * pow(NdotHV, materialShininess);\n    }\n\n    vec3 tn;\n    vec2 tc;\n    <% for (var i = 0; i < textures.length; i++) { %>\n      tc = vTexCoords * TEXTURE<%=i%>_SCALE + TEXTURE<%=i%>_OFFSET;\n      if (TEXTURE<%=i%>_TYPE == <%=Jax.NORMAL_MAP%>) {\n        tn = normalize(texture2D(TEXTURE<%=i%>, tc).xyz * 2.0 - 1.0);\n        diffuse *= max(dot(nTbnDirToLight, tn), 0.0);\n      } else ambient *= texture2D(TEXTURE<%=i%>, tc);\n    <% } %>\n\n    gl_FragColor = ambient + diffuse;\n  } else discard;\n}\n",
  vertex:"attribute vec2 VERTEX_TEXCOORDS;\nattribute vec3 VERTEX_NORMAL;\nattribute vec4 VERTEX_POSITION, VERTEX_COLOR, VERTEX_TANGENT;\n\nvoid main(void) {\n  vBaseColor = VERTEX_COLOR;\n  vNormal = nMatrix * VERTEX_NORMAL;\n  vTexCoords = VERTEX_TEXCOORDS;\n\n  vec3 tangent = nMatrix * VERTEX_TANGENT.xyz;\n  vec3 bitangent = cross(vNormal, tangent) * VERTEX_TANGENT.w;\n  vec3 dirToEye = -(mvMatrix * VERTEX_POSITION).xyz;\n  vec3 tbnDirToEye = vec3(dot(dirToEye, tangent),\n                          dot(dirToEye, bitangent),\n                          dot(dirToEye, vNormal));\n                          \n  vLightDir = normalize(vnMatrix * -normalize(LIGHT_DIRECTION));\n  vTbnDirToLight.x = dot(vLightDir, tangent);\n  vTbnDirToLight.y = dot(vLightDir, bitangent);\n  vTbnDirToLight.z = dot(vLightDir, vNormal);\n\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n}\n",
name: "basic"});
