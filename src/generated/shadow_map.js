Jax.shaders['shadow_map'] = new Jax.Shader({  common:"shared uniform mat4 mMatrix;\n\nuniform bool SHADOWMAP_ENABLED;\nuniform sampler2D SHADOWMAP0, SHADOWMAP1;\nuniform mat4 SHADOWMAP_MATRIX;\nuniform bool SHADOWMAP_PCF_ENABLED;\nuniform float DP_SHADOW_NEAR, DP_SHADOW_FAR;\n\nvarying vec4 vShadowCoord;\n\nvarying vec3 vDP0, vDP1;\nvarying float vDPz, vDPDepth;\n",
  fragment:"vec4 pack_depth(const in float depth)\n{\n  const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n  const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n  vec4 res = fract(depth * bit_shift);\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\n/*\nfloat linearize(in float z) {\n  float A = pMatrix[2].z, B = pMatrix[3].z;\n  float n = - B / (1.0 - A); // camera z near\n  float f =   B / (1.0 + A); // camera z far\n  return (2.0 * n) / (f + n - z * (f - n));\n}\n*/\n\nfloat unpack_depth(const in vec4 rgba_depth)\n{\n  const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n  float depth = dot(rgba_depth, bit_shift);\n  return depth;\n}\n\n\n\nfloat dp_lookup() {\n  float map_depth, depth;\n  vec4 rgba_depth;\n      \n  if (vDPz > 0.0) {\n    rgba_depth = texture2D(SHADOWMAP0, vDP0.xy);\n    depth = vDPDepth;//P0.z;\n  } else {\n    rgba_depth = texture2D(SHADOWMAP1, vDP1.xy);\n    depth = vDPDepth;//P1.z;\n  }\n      \n      \n  map_depth = unpack_depth(rgba_depth);\n      \n  if (map_depth + 0.00005 < depth) return 0.0;\n  else return 1.0;\n}\n      \nfloat pcf_lookup(float s, vec2 offset) {\n  /*\n    s is the projected depth of the current vShadowCoord relative to the shadow's camera. This represents\n    a *potentially* shadowed surface about to be drawn.\n    \n    d is the actual depth stored within the SHADOWMAP texture (representing the visible surface).\n  \n    if the surface to be drawn is further back than the light-visible surface, then the surface is\n    shadowed because it has a greater depth. Less-or-equal depth means it's either in front of, or it *is*\n    the light-visible surface.\n  */\n  float d = unpack_depth(texture2D(SHADOWMAP0, (vShadowCoord.xy/vShadowCoord.w)+offset));\n  return (s - d > 0.00002) ? 0.0 : 1.0;\n}\n\nvoid main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n//ambient = vec4(0);\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%> || !SHADOWMAP_ENABLED) return;\n  \n  float visibility = 1.0;\n  float s = vShadowCoord.z / vShadowCoord.w;\n  if (LIGHT.type == <%=Jax.POINT_LIGHT%>) {\n    visibility = dp_lookup();\n  } else {\n    if (!SHADOWMAP_PCF_ENABLED)\n      visibility = pcf_lookup(s, vec2(0.0,0.0));\n    else {\n      /* do PCF filtering */\n      float dx, dy;\n      visibility = 0.0;\n      for (float dx = -1.5; dx <= 1.5; dx += 1.0)\n        for (float dy = -1.5; dy <= 1.5; dy += 1.0)\n          visibility += pcf_lookup(s, vec2(dx/2048.0, dy/2048.0));\n      visibility /= 16.0;\n    }\n  }\n\n//  if (vDPz > 0.0) {\n//    diffuse = texture2D(SHADOWMAP0, vDP0.xy);\n//  } else {\n//    diffuse = texture2D(SHADOWMAP1, vDP1.xy);\n//  }\n//  specular = vec4(0);\n\n  diffuse *= visibility;\n  specular *= visibility;\n\n//diffuse = vec4(vShadowCoord.xy/vShadowCoord.w, 0, 1);\n//diffuse = max(texture2D(SHADOWMAP0, (vShadowCoord.xy/vShadowCoord.w)), texture2D(SHADOWMAP1, (vShadowCoord.xy/vShadowCoord.w)));\n//  diffuse  = vec4(visibility);\n//  specular = vec4(0);\n//  specular *= visibility;\n}\n",
  vertex:"void main(void) {\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%> || !SHADOWMAP_ENABLED) return;\n\n  vShadowCoord = SHADOWMAP_MATRIX * mMatrix * VERTEX_POSITION;\n  \n//  if (LIGHT.type == <%=Jax.POINT_LIGHT%>) {\n    /* Perform dual-paraboloid shadow map calculations - for point lights only */\n    vec4 p = vShadowCoord;\n    vec3 pos = p.xyz / p.w;\n          \n    float L = length(pos.xyz);\n    vDP0 = pos / L;\n    vDP1 = pos / L;\n          \n    vDPz = pos.z;\n          \n    vDP0.z = 1.0 + vDP0.z;\n    vDP0.x /= vDP0.z;\n    vDP0.y /= vDP0.z;\n    vDP0.z = (L - DP_SHADOW_NEAR) / (DP_SHADOW_FAR - DP_SHADOW_NEAR);\n          \n    vDP0.x =  0.5 * vDP0.x + 0.5;\n    vDP0.y =  0.5 * vDP0.y + 0.5;\n          \n    vDP1.z = 1.0 - vDP1.z;\n    vDP1.x /= vDP1.z;\n    vDP1.y /= vDP1.z;\n    vDP1.z = (L - DP_SHADOW_NEAR) / (DP_SHADOW_FAR - DP_SHADOW_NEAR);\n      \n    vDP1.x =  0.5 * vDP1.x + 0.5;\n    vDP1.y =  0.5 * vDP1.y + 0.5;\n          \n    float map_depth, depth;\n    vec4 rgba_depth;\n          \n    if (vDPz > 0.0) {\n      vDPDepth = vDP0.z;\n    } else {\n      vDPDepth = vDP1.z;\n    }\n//  }\n}\n",
exports: {},
name: "shadow_map"});
