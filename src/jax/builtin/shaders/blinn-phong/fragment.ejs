float LightAttenuation;
      
float unpack_depth(const in vec4 rgba_depth)
{
  const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
  float depth = dot(rgba_depth, bit_shift);
  return depth;
}
      
vec4 pack_depth(const in float depth)
{
  const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
  const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
  vec4 res = fract(depth * bit_shift);
  res -= res.xxyz * bit_mask;
  return res;
}


float dp_lookup() {
  float map_depth, depth;
  vec4 rgba_depth;
      
  if (vDPz > 0.0) {
    rgba_depth = texture2D(SHADOWMAP0, vDP0.xy);
    depth = vDPDepth;//P0.z;
  } else {
    rgba_depth = texture2D(SHADOWMAP1, vDP1.xy);
    depth = vDPDepth;//P1.z;
  }
      
      
  map_depth = unpack_depth(rgba_depth);
      
  if (map_depth + 0.00005 < depth) return 0.0;
  else return 1.0;
}
      
float pcf_lookup(float s, vec2 offset) {
  /*
    s is the projected depth of the current vShadowCoord relative to the shadow's camera. This represents
    a *potentially* shadowed surface about to be drawn.
    
    d is the actual depth stored within the SHADOWMAP texture (representing the visible surface).
  
    if the surface to be drawn is further back than the light-visible surface, then the surface is
    shadowed because it has a greater depth. Less-or-equal depth means it's either in front of, or it *is*
    the light-visible surface.
  */
  float d = unpack_depth(texture2D(SHADOWMAP0, (vShadowCoord.xy/vShadowCoord.w)+offset));
  return (s - d > 0.00002) ? 0.0 : 1.0;
}
      
void main() {
  vec3 nTbnDirToLight;// = normalize(vTbnDirToLight);
  vec4 final_color = vec4(0,0,0,0);
  float spotEffect, att = 1.0, visibility = 1.0;
      
  if (PASS_TYPE == <%=Jax.Scene.ILLUMINATION_PASS%>) {
    if (LIGHT_ENABLED) {
      LightAttenuation = (LIGHT_ATTENUATION_CONSTANT 
                         + LIGHT_ATTENUATION_LINEAR    * vDist
                         + LIGHT_ATTENUATION_QUADRATIC * vDist * vDist);
      
      if (SHADOWMAP_ENABLED) {
        float s = vShadowCoord.z / vShadowCoord.w;
        if (LIGHT_TYPE == <%=Jax.POINT_LIGHT%>) {
          visibility = dp_lookup();
        } else {
          if (!SHADOWMAP_PCF_ENABLED)
            visibility = pcf_lookup(s, vec2(0.0,0.0));
          else {
            /* do PCF filtering */
            float dx, dy;
            visibility = 0.0;
            for (float dx = -1.5; dx <= 1.5; dx += 1.0)
              for (float dy = -1.5; dy <= 1.5; dy += 1.0)
                visibility += pcf_lookup(s, vec2(dx/2048.0, dy/2048.0));
            visibility /= 16.0;
          }
        }
      }

      vec3 nLightDir = normalize(vLightDir), nNormal = normalize(vNormal);
      vec3 halfVector = normalize(nLightDir + vec3(0.0,0.0,1.0));
      float NdotL = max(dot(nNormal, nLightDir), 0.0);
      nTbnDirToLight.x = dot(vLightDir, normalize(vTangent));  
      nTbnDirToLight.y = dot(vLightDir, normalize(vBitangent));  
      nTbnDirToLight.z = dot(vLightDir, nNormal);
      nTbnDirToLight = normalize(nTbnDirToLight);


      if (LIGHT_TYPE != <%=Jax.SPOT_LIGHT%> || 
        (spotEffect = dot(normalize(vSpotlightDirection), nLightDir)) > SPOTLIGHT_COS_CUTOFF
      ) {
        if (LIGHT_TYPE != <%=Jax.DIRECTIONAL_LIGHT%>) {
          if (LIGHT_TYPE == <%=Jax.SPOT_LIGHT%>) { att = pow(spotEffect, SPOTLIGHT_EXPONENT); }
        
          att = att / LightAttenuation;
        }
        
        final_color += visibility * att * LIGHT_AMBIENT;
        if (NdotL > 0.0) {
          float NdotHV = max(dot(nNormal, halfVector), 0.0);
          final_color += visibility * att * NdotL * materialDiffuse * LIGHT_DIFFUSE; /* diffuse */
          final_color += visibility * att * materialSpecular * LIGHT_SPECULAR * pow(NdotHV, materialShininess); /* specular */
        }
      }

      vec3 tn;
      <% for (var i = 0; i < textures.length; i++) { %>
          if (TEXTURE<%=i%>_TYPE == <%=Jax.NORMAL_MAP%>) {
            tn = normalize(texture2D(TEXTURE<%=i%>, vTexCoords * TEXTURE<%=i%>_SCALE + TEXTURE<%=i%>_OFFSET).xyz * 2.0 - 1.0);
            final_color *= max(dot(nTbnDirToLight, tn), 0.0);
          }
          else
            final_color *= texture2D(TEXTURE<%=i%>, vTexCoords * TEXTURE<%=i%>_SCALE + TEXTURE<%=i%>_OFFSET);
      <% } %>
    }
  } else {
    final_color += materialAmbient * vBaseColor;
    <% for (var i = 0; i < textures.length; i++) { %>
        final_color *= vec4(1,1,1,texture2D(TEXTURE<%=i%>, vTexCoords * TEXTURE<%=i%>_SCALE + TEXTURE<%=i%>_OFFSET).a);
    <% } %>
  }
      
  gl_FragColor = final_color;
}
