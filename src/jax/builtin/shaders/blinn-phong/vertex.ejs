/* attributes */
shared attribute vec2 VERTEX_TEXCOORDS;
shared attribute vec4 VERTEX_POSITION, VERTEX_COLOR, VERTEX_TANGENT;
shared attribute vec3 VERTEX_NORMAL;
 
void calculateDPLighting() {
//        vShadowCoord = mvMatrix * vec4(VERTEX_POSITION.xyz, 1.0);
  vec4 p = vShadowCoord;
  vec3 pos = p.xyz / p.w;
        
  float L = length(pos.xyz);
  vDP0 = pos / L;
  vDP1 = pos / L;
        
  vDPz = pos.z;
        
  vDP0.z = 1.0 + vDP0.z;
  vDP0.x /= vDP0.z;
  vDP0.y /= vDP0.z;
  vDP0.z = (L - DP_SHADOW_NEAR) / (DP_SHADOW_FAR - DP_SHADOW_NEAR);
        
  vDP0.x =  0.5 * vDP0.x + 0.5;
  vDP0.y =  0.5 * vDP0.y + 0.5;
        
  vDP1.z = 1.0 - vDP1.z;
  vDP1.x /= vDP1.z;
  vDP1.y /= vDP1.z;
  vDP1.z = (L - DP_SHADOW_NEAR) / (DP_SHADOW_FAR - DP_SHADOW_NEAR);
    
  vDP1.x =  0.5 * vDP1.x + 0.5;
  vDP1.y =  0.5 * vDP1.y + 0.5;
        
  float map_depth, depth;
  vec4 rgba_depth;
        
  if (vDPz > 0.0) {
    vDPDepth = vDP0.z;
  } else {
    vDPDepth = vDP1.z;
  }
}
      
void main() {
  vBaseColor = VERTEX_COLOR;
  vNormal = nMatrix * VERTEX_NORMAL;
  vTexCoords = VERTEX_TEXCOORDS;
      
  /* if it's an ambient pass, then we don't even care about light information */
  if (PASS_TYPE == <%=Jax.Scene.ILLUMINATION_PASS%>) {
    if (SHADOWMAP_ENABLED) {
      vShadowCoord = SHADOWMAP_MATRIX * mMatrix * VERTEX_POSITION;
    }
          
    if (LIGHT_TYPE == <%=Jax.DIRECTIONAL_LIGHT%>) {
      vLightDir = normalize(vnMatrix * -LIGHT_DIRECTION);
    } else {
      if (LIGHT_TYPE == <%=Jax.POINT_LIGHT%>) calculateDPLighting();
      vec3 vec = (ivMatrix * vec4(LIGHT_POSITION, 1)).xyz - (mvMatrix * VERTEX_POSITION).xyz;
      vLightDir = normalize(vec);
      vDist = length(vec);
    }
      
    /* tangent info for normal mapping */
    vTangent = nMatrix * VERTEX_TANGENT.xyz;
    vBitangent = cross(vNormal, vTangent) * VERTEX_TANGENT.w; // w is handedness
          
    /* if it's a spotlight, calculate spotlightDirection */
    if (LIGHT_TYPE == <%=Jax.SPOT_LIGHT%>) {
      vSpotlightDirection = normalize(vnMatrix * -LIGHT_DIRECTION);
    }
  }
      
  gl_Position = pMatrix * mvMatrix * vec4(VERTEX_POSITION.xyz, 1);
}
