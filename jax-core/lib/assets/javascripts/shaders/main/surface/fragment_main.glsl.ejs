vec4 BaseColor = vVertexColor;

<% if (textures.length) { %>
  <% for (var i = 0; i < textures.length; i++) { %>
    BaseColor *= texture2D(Textures[<%= i %>], vVertexTexCoords);
  <% } %>
<% } %>

// the lighting calculations past this point only apply to RGB, for opacity
// we're done
gl_FragColor.a = BaseColor.a
                 * MaterialAmbientColor.a
                 + MaterialDiffuseColor.a
                 + MaterialSpecularColor.a;

if (WorldAmbientEnabled) {
  gl_FragColor.rgb = BaseColor.rgb
                     * WorldAmbientColor.a
                     * WorldAmbientColor.rgb
                     * MaterialAmbientIntensity;
} else {
  gl_FragColor.rgb = vec3(0.0, 0.0, 0.0);
}


vec3 ambientLightColor, diffuseLightColor, specularLightColor;
float spotAttenuation, lightDistanceFromSurface;
float specularMultiplier = 1.0;;

<% if (normalMaps.length) { %>
  vec3 eyeSpaceSurfaceNormal    = normalize(vEyeSpaceSurfaceNormal);
  vec3 eyeSpaceSurfaceTangent   = normalize(vEyeSpaceSurfaceTangent);
  vec3 eyeSpaceSurfaceBitangent = normalize(vEyeSpaceSurfaceBitangent);

  vec4 temp = vec4(0.0, 0.0, 0.0, 1.0);
  vec3 finalNormal = vec3(0.0, 0.0, 0.0);
  <% for (var i = 0; i < normalMaps.length; i++) { %>
    temp = NormalMapLookup(NormalMaps[<%= i %>],
                           NormalMapScales[<%= i %>] * vVertexTexCoords,
                           eyeSpaceSurfaceNormal,
                           eyeSpaceSurfaceTangent,
                           eyeSpaceSurfaceBitangent);
    finalNormal += temp.xyz;
    if (NormalMapSpecular[<%= i %>]) {
      specularMultiplier = min(temp.a, specularMultiplier);
    }
  <% } %>
  eyeSpaceSurfaceNormal = normalize(finalNormal);
<% } else { %>
  vec3 eyeSpaceSurfaceNormal = normalize(vEyeSpaceSurfaceNormal);
<% } %>

// Perform lighting calculations properly when rendering a back face with
// CULL_FACE disabled or set to FRONT
if (!gl_FrontFacing) eyeSpaceSurfaceNormal = -eyeSpaceSurfaceNormal;

vec3 attenuatedLightColor, directLightColor;
<% for (var i = 0; i < Jax.Material.Surface.MAX_LIGHTS_PER_PASS; i++) { %>
  if (LightEnabled[<%= i %>]) {
    LightAmbient(MaterialAmbientIntensity,
                 MaterialAmbientColor,
                 LightAmbientColor[<%= i %>],
                 ambientLightColor);

    LambertDiffuse(eyeSpaceSurfaceNormal,
                   vEyeSpaceSurfacePosition,
                   EyeSpaceLightDirection[<%= i %>],
                   EyeSpaceLightPosition[<%= i %>],
                   MaterialDiffuseIntensity,
                   MaterialDiffuseColor,
                   LightType[<%= i %>],
                   LightSpotInnerCos[<%= i %>],
                   LightSpotOuterCos[<%= i %>],
                   LightDiffuseColor[<%= i %>],
                   diffuseLightColor,
                   spotAttenuation,
                   lightDistanceFromSurface);

    PhongSpecular(eyeSpaceSurfaceNormal,
                   vEyeSpaceSurfacePosition,
                   EyeSpaceLightDirection[<%= i %>],
                   EyeSpaceLightPosition[<%= i %>],
                   MaterialShininess,
                   MaterialSpecularIntensity,
                   MaterialSpecularColor,
                   LightType[<%= i %>],
                   LightSpotInnerCos[<%= i %>],
                   LightSpotOuterCos[<%= i %>],
                   LightDiffuseColor[<%= i %>],
                   specularLightColor,
                   spotAttenuation);

    directLightColor = diffuseLightColor + specularLightColor
                                         * specularMultiplier;
    if (SHADOWMAP_ENABLED[<%= i %>])
      directLightColor *= ShadowMapLookup(vShadowCoord[<%= i %>],
                                          SHADOWMAP_WIDTH[<%= i %>],
                                          SHADOWMAP_HEIGHT[<%= i %>],
                                          IsDualParaboloid[<%= i %>],
                                          SHADOWMAP0[<%= i %>],
                                          SHADOWMAP1[<%= i %>],
                                          ParaboloidNear[<%= i %>],
                                          ParaboloidFar[<%= i %>]);

    attenuatedLightColor = ambientLightColor + directLightColor;
    LightAttenuation(lightDistanceFromSurface,
                     spotAttenuation,
                     LightConstantAttenuation[<%= i %>],
                     LightLinearAttenuation[<%= i %>],
                     LightQuadraticAttenuation[<%= i %>],
                     attenuatedLightColor);
    
    gl_FragColor.rgb += attenuatedLightColor * BaseColor.rgb;
  }
<% } %>

FogColorEXP2(gl_FragColor.rgb, FogColor.rgb, gl_FragColor.rgb,
             vEyeZ, FogDensity);
